# Copyright 2019-2023 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Tests GDBs support for OpenMP when there are function calls inside
# the kernel.

load_lib openmp.exp

foreach extension $openmp_languages_list {
    set device_list [omp_get_device_list $extension]
    if {[llength $device_list] == 0} {
	unsupported "target does not support OpenMP ${extension}"
	continue
    }

    standard_testfile "call-stack.${extension}"
    set exe "${binfile}_${extension}"

    if {[prepare_openmp_for_testing ${exe} ${srcfile} $extension] == -1} {
	untested "OpenMP: Fail to prepare the test ${exe}"
	continue
    }

    foreach device_info "${device_list}" {
	with_test_prefix [init_openmp_device $device_info $extension] {

	    if {![start_openmp_program $extension]} {
		untested "Fail to start the program"
		continue
	    }

	    set inner_loc [gdb_get_line_number "ordinary-inner-loc"]
	    set middle_loc [gdb_get_line_number "ordinary-middle-loc"]
	    set outer_loc [gdb_get_line_number "ordinary-outer-loc"]
	    set inlined_inner_loc [gdb_get_line_number "inlined-inner-loc"]
	    set inlined_middle_loc [gdb_get_line_number "inlined-middle-loc"]
	    set inlined_outer_loc [gdb_get_line_number "inlined-outer-loc"]

	    set fill "\[^\r\n\]*"
	    if {$extension eq "cpp"} {
		set main_func_name "main"
	    } else {
		set main_func_name "MAIN__"
	    }

	    set inner_desc  "second \\(x=20, y=9\\) at ${fill}$srcfile:$inner_loc"
	    set middle_desc "first \\(num1=16, num2=3\\) at ${fill}$srcfile:$middle_loc"
	    set outer_desc  "$main_func_name.* at .*$srcfile:$outer_loc"

	    set inlined_inner_desc \
		"inlined_second ${fill} at ${fill}$srcfile:$inlined_inner_loc"
	    set inlined_middle_desc \
		"inlined_first ${fill} at ${fill}$srcfile:$inlined_middle_loc"
	    set inlined_outer_desc \
		"$main_func_name.* at ${fill}$srcfile:$inlined_outer_loc"

	    # Test breaking on function names inside the kernel.
	    gdb_breakpoint "$srcfile:first"
	    gdb_continue_to_breakpoint "break_at_first" ".*$srcfile:$middle_loc.*"

	    # Set breakpoint inside the kernel.
	    gdb_breakpoint "$srcfile:$inner_loc"
	    gdb_continue_to_breakpoint "innermost-body" ".*$srcfile:$inner_loc.*"

	    # Currently failure is due to wrapper calls for all ifx testing.
	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    # Limit the backtrace to 3 frames because frame #3
	    # and beyond are implementation-specific to the OpenMP runtime.
	    gdb_test "backtrace 3" [multi_line \
		"#$decimal.* $inner_desc" \
		"#$decimal.* $middle_desc" \
		"#$decimal.* $outer_desc.*"] \
		"backtrace, test 1"

	    set frame_num 1
	    if {$extension eq "f90"} {
		set frame_num 2
	    }
	    # Now switch frames and examine locals.
	    gdb_test "frame $frame_num" ".*#${frame_num}.* $middle_desc.*" \
		"switch to frame 1"
	    # Currently failure is due to wrapper calls for all ifx testing since
	    # frame 1 is the wrapper call.
	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    gdb_test "print num1" "= 16" "print num1 at first bp"

	    # Currently failure is due to wrapper calls for all ifx testing since
	    # frame 1 is the wrapper call.
	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    gdb_test "print num2" "= 3" "print num2 at first bp"

	    # Currently failure is due to wrapper calls for all ifx testing since
	    # frame 1 is the wrapper call which is unexpected for this test.
	    set frame_num 2
	    if {$extension eq "f90"} {
		set frame_num 4
	    }
	    gdb_test "frame $frame_num" ".*#${frame_num}.* $outer_desc.*" \
		"switch to frame ${frame_num}"
	    # Currently failing due to wrapper calls in call stack.
	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    gdb_test "print fifteen" "= 15" "print fifteen at first bp"
	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    gdb_test "print five" "= 5"
	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    gdb_test "print ten" "= 10"

	    gdb_test "frame 0" ".*#0.* $inner_desc.*" "switch to frame 0"

	    gdb_test "print x" "= 20" "print x at first bp"
	    gdb_test "print y" "= 9" "print y at first bp"

	    # Finish the function calls.  Normally we expect to see a "Value
	    # returned is ..." line.  However, some OpenMP device compilers may
	    # inline the kernel functions.  In that case we won't get that line.
	    set value_returned "(\r\nValue returned is $valnum_re = 180)?"

	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    gdb_test "finish" [multi_line \
		"Run till exit from #0 $fill second \\(x=20, y=9\\) $fill" \
		"${fill}first \\(num1=16, num2=3\\)${fill}" \
		"${fill}${value_returned}"] \
		"finish the innermost frame"

	    # 'finish' may not have stopped at the perfect spot.  Redefine
	    # 'middle_desc' to prevent error propagation.
	    set middle_desc "first .* at .*$srcfile:$decimal"

	    # Currently failing due to wrapper calls in call stack.
	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    gdb_test "backtrace 2" [multi_line \
		"#$decimal.* $middle_desc.*" \
		"#$decimal.* $outer_desc.*"] \
		"backtrace, test 2"

	    set value_returned "(\r\nValue returned is $valnum_re = 210)?"

	    # Currently failing due to wrapper calls in call stack.
	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    gdb_test "finish" [multi_line \
		"Run till exit from #0 $fill first \\(num1=16, num2=3\\) $fill.*" \
		"${fill}$main_func_name${fill}" \
		"${fill}${value_returned}"] \
		"finish the middle frame"

	    # Failing due to wrapper calls in call stack.
	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    gdb_test "backtrace 1" "#0${fill} $outer_desc.*" \
		"backtrace, test 3"

	    # Test inlined function calls.
	    gdb_breakpoint "$srcfile:$inlined_inner_loc"

	    gdb_continue_to_breakpoint "inlined-body" \
		".*$srcfile:$inlined_inner_loc.*"

	    gdb_test "backtrace 3" [multi_line \
		"#${decimal}.* $inlined_inner_desc" \
		"#${decimal}${fill} $inlined_middle_desc" \
		"#${decimal}${fill} $inlined_outer_desc.*"] \
		"backtrace for inlined calls"

	    gdb_test "frame 1" ".*#1.* $inlined_middle_desc.*" \
		"switch to frame 1; inlined"
	    gdb_test "print num1" "= 10" "print num1 at second bp"
	    gdb_test "print num2" "= 2" "print num2 at second bp"

	    gdb_test "frame 2" ".*#2.* $inlined_outer_desc.*" \
		"switch to frame 2; inlined"
	    gdb_test "print fifteen" "= 15" "print fifteen at second bp"

	    gdb_test "frame 0" ".*#0.* $inlined_inner_desc.*" \
		"switch to frame 0; inlined"
	    gdb_test "print x" "= 14" "print x at second bp"
	    gdb_test "print y" "= 6" "print y at second bp"

	    # Test defining a breakpoint using the function name.
	    delete_breakpoints
	    gdb_breakpoint "$srcfile:second"

	    gdb_continue_to_breakpoint "function 'second'" ".*"
	    # Failing due to wrapper calls in call stack.
	    if {$extension eq "f90"} {
		setup_kfail "JIRA DOQG/2694" "*-*-*"
	    }
	    gdb_test "backtrace 3" [multi_line \
		"#${decimal}.* second .*" \
		"#${decimal}.* $middle_desc.*" \
		"#${decimal}.* $main_func_name.* at .*"] \
		"backtrace, test 4"

	    continue_openmp_program_to_termination
	}
    }
}
