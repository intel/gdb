# Copyright 2019-2021 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Tests GDBs support for OpenMP when there are function calls inside
# the kernel.

load_lib openmp.exp

if {[skip_openmp_tests]} {
    untested "skipping openmp test"
    return 0
}

standard_testfile call-stack.${openmp_program_extension}

if {[start_openmp_program]} {
    return -1
}

set inner_loc [gdb_get_line_number "ordinary-inner-loc"]
set middle_loc [gdb_get_line_number "ordinary-middle-loc"]
set outer_loc [gdb_get_line_number "ordinary-outer-loc"]
set inlined_inner_loc [gdb_get_line_number "inlined-inner-loc"]
set inlined_middle_loc [gdb_get_line_number "inlined-middle-loc"]
set inlined_outer_loc [gdb_get_line_number "inlined-outer-loc"]

set inner_desc  "second .* at .*$srcfile:$inner_loc"
set middle_desc "first .* at .*$srcfile:$middle_loc"

if {$openmp_program_extension eq "cpp"} {
    set outer_desc  "main.* at .*$srcfile:$outer_loc"
    set inlined_outer_desc \
	"main.* at .*$srcfile:$inlined_outer_loc"
} else {
    set outer_desc  "MAIN__.* at .*$srcfile:$outer_loc"
    set inlined_outer_desc \
	"MAIN__.* at .*$srcfile:$inlined_outer_loc"
}
set inlined_inner_desc \
    "inlined_second .* at .*$srcfile:$inlined_inner_loc"
set inlined_middle_desc \
    "inlined_first .* at .*$srcfile:$inlined_middle_loc"

# Test breaking on function names inside the kernel.
gdb_breakpoint "first"
if {[require_openmp_device "GPU"]} {
    setup_kfail "JIRA DOQG/2350" "*-*-*"
}
gdb_continue_to_breakpoint "break_at_first" ".*$srcfile:$middle_loc.*"

# Set breakpoint inside the kernel.
gdb_breakpoint "$srcfile:$inner_loc"
gdb_continue_to_breakpoint "innermost-body" ".*$srcfile:$inner_loc.*"

# Limit the backtrace to 3 frames because frame #3
# and beyond are implementation-specific to the OpenMP runtime.
gdb_test "backtrace 3" [multi_line \
    "#0.* $inner_desc" \
    "#1.* $middle_desc" \
    "#2.* $outer_desc.*"] \
    "backtrace, test 1"

# Now switch frames and examine locals.
gdb_test "frame 1" ".*#1.* $middle_desc.*" "switch to frame 1"
if {![info exists env(LIBOMPTARGET_DEVICETYPE)] && \
    $openmp_program_extension eq "f90"} {
    setup_kfail "JIRA CMPLRLLVM/25254" "*-*-*"
}
gdb_test "print num1" "= 15" "print num1 at first bp"

if {$openmp_program_extension eq "f90"
    && (![info exists env(LIBOMPTARGET_DEVICETYPE)]
	|| [require_openmp_device "GPU"])} {
    setup_kfail "JIRA CMPLRLLVM/25254" "*-*-*"
}
gdb_test "print num2" "= 3" "print num2 at first bp"

gdb_test "frame 2" ".*#2.* $outer_desc.*" "switch to frame 2"
gdb_test "print fourteen" "= 14" "print fourteen at first bp"
gdb_test "print four" "= 4"
gdb_test "print ten" "= 10"

gdb_test "frame 0" ".*#0.* $inner_desc.*" "switch to frame 0"
gdb_test "print x" "= 20" "print x at first bp"
gdb_test "print y" "= 9" "print y at first bp"

# Finish the two function calls.
if {[require_openmp_device "GPU"]} {
    setup_kfail "JIRA DOQG/2350" "*-*-*"
}
gdb_test "finish" \
    ".*Value returned is $valnum_re = 180" \
    "finish the innermost frame"

# 'finish' may not have stopped at the perfect spot.  Redefine
# 'middle_desc' to prevent error propagation.
set middle_desc "first .* at .*$srcfile:$decimal"

gdb_test "backtrace 2" [multi_line \
    "#0.* $middle_desc.*" \
    "#1.* $outer_desc.*"] \
    "backtrace, test 2"

if {[require_openmp_device "GPU"]} {
    setup_kfail "JIRA DOQG/2350" "*-*-*"
}
gdb_test "finish" \
    ".*Value returned is $valnum_re = 210" \
    "finish the middle frame"

# On GPU, the failure above causes a domino effect.
if {[require_openmp_device "GPU"]} {
    return 1
}

gdb_test "backtrace 1" "#0.* $outer_desc.*" \
    "backtrace, test 3"

# Test inlined function calls.
gdb_breakpoint $inlined_inner_loc

gdb_continue_to_breakpoint "inlined-body" ".*$srcfile:$inlined_inner_loc.*"

gdb_test "backtrace 3" [multi_line \
    "#0.* $inlined_inner_desc" \
    "#1.* $inlined_middle_desc" \
    "#2.* $inlined_outer_desc.*"] \
    "backtrace for inlined calls"

gdb_test "frame 1" ".*#1.* $inlined_middle_desc.*" \
    "switch to frame 1; inlined"
if {![info exists env(LIBOMPTARGET_DEVICETYPE)] && \
    $openmp_program_extension eq "f90"} {
    kfail "JIRA CMPLRLLVM/25254" "info args fails on IFX OpenMP Host offload"
} else {
    gdb_test "print num1" "= 10" "print num1 at second bp"
    gdb_test "print num2" "= 2" "print num2 at second bp"
}

gdb_test "frame 2" ".*#2.* $inlined_outer_desc.*" \
    "switch to frame 2; inlined"
gdb_test "print fourteen" "= 14" "print fourteen at second bp"

gdb_test "frame 0" ".*#0.* $inlined_inner_desc.*" \
    "switch to frame 0; inlined"
gdb_test "print x" "= 15" "print x at second bp"
gdb_test "print y" "= 6" "print y at second bp"

# Test defining a breakpoint using the function name.
delete_breakpoints
gdb_breakpoint "second"

gdb_continue_to_breakpoint "function 'second'" ".*"
if {$openmp_program_extension eq "cpp"} {
    gdb_test "backtrace 3" [multi_line \
	"#0.* second .*" \
	"#1.* $middle_desc.*" \
	"#2.* main.* at .*"] \
	"backtrace, test 4"
} else {
    gdb_test "backtrace 3" [multi_line \
	"#0.* second .*" \
	"#1.* $middle_desc.*" \
	"#2.* MAIN__.* at .*"] \
	"backtrace, test 4"
}

continue_openmp_program_to_termination
