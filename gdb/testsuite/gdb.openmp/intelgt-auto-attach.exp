# Copyright 2020-2022 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Test the auto-attach script for Intel GT by terminating/killing/detaching
# the host/gt inferior.

load_lib openmp.exp

if [use_gdb_stub] {
    return
}

# Run until the end, potentially with BPs inside and outside the kernel.

proc run_end_to_end {has_kernel_bp has_outside_bp extension} {
    global srcfile

    if {![openmp_run_to_main $extension]} {
	fail "run the program"
	return -1
    } else {
	pass "run the program"
    }

    if {$has_kernel_bp} {
	set kernel_bp [gdb_get_line_number "kernel-line-3"]
	gdb_breakpoint $kernel_bp

	gdb_continue_to_breakpoint "inside the kernel" \
	    ".*$srcfile:$kernel_bp.*"
    }
    set kfail ""
    if {[omp_is_level_zero_debug_api]} {
	set kfail "JIRA XDEPS/5062"
    }
    if {$has_outside_bp} {
	set end_bp [gdb_get_line_number "return-stmt"]
	gdb_breakpoint $end_bp

	if {[omp_is_level_zero_debug_api]} {
	    setup_kfail $kfail "*-*-*"
	}
	gdb_continue_to_breakpoint "outside the kernel" \
	    ".*$srcfile:$end_bp.*"
    }

    continue_openmp_program_to_termination "" "${kfail}"
}

# Run up to a BP, then kill/detach an inferior.

proc run_to_bp {which_bp scenario iter extension} {
    global srcfile

    if {![openmp_run_to_main $extension]} {
	fail "run the program"
        return -1
    } else {
	pass "run the program"
    }

    if {$which_bp eq "inside"} {
	set kernel_bp [gdb_get_line_number "kernel-line-3"]
	gdb_breakpoint $kernel_bp

	gdb_continue_to_breakpoint "inside the kernel" \
	    ".*$srcfile:$kernel_bp.*"
    } else {
	set end_bp [gdb_get_line_number "return-stmt"]
	gdb_breakpoint $end_bp

	if {[omp_is_level_zero_debug_api]} {
	    setup_kfail "JIRA XDEPS/5062" "*-*-*"
	}
	gdb_continue_to_breakpoint "outside the kernel" \
	    ".*$srcfile:$end_bp.*"
    }

    # Host inferior ID is always 1.
    set host_inf 1
    # GT inferior is created anew each time we run.
    set gt_inf [expr $iter + 1]
    set fill "\[^\r\n\]*"

    set output ".*inferior $gt_inf $fill has been removed.*"
    if {$scenario eq "kill_host"} {
	gdb_test "kill inferiors $host_inf" $output
    } elseif {$scenario eq "detach_host"} {
	gdb_test "detach inferiors $host_inf" $output
    } elseif {$scenario eq "detach_gt"} {
	gdb_test "detach inferiors $gt_inf" $output
    }
}

# Test restarting the host and gt inferior while debugging a kernel.
# Run up to a BP and try to restart the gt inferior, which should fail.  Then,
# switch to the host inferior and restart execution.  Do this with non-stop
# mode set to either "on" or "off".

proc run_restart_scenario {non_stop_mode extension} {
    global srcfile

    gdb_test_no_output "set non-stop $non_stop_mode"

    if {![openmp_run_to_main $extension] < 0} {
	fail "run the program"
	return -1
    } else {
	pass "run the program"
    }

    # Remove the breakpoint set for main, since we want to restart.
    delete_breakpoints

    # Set a breakpoint inside the kernel and hit it.
    set inside_kernel [gdb_get_line_number "kernel-line-1"]
    gdb_breakpoint "$srcfile:$inside_kernel"
    gdb_continue_to_breakpoint "kernel line" \
	".*$srcfile:$inside_kernel.*"

    if {$non_stop_mode eq "on"} {
	# In non-stop mode we should still sit at the host inferior.
	gdb_test "inferior 2" "Switching to inferior 2.*" "switch to gt inferior"
    }

    # Restarting the gt inferior is disabled.
    gdb_test "run" \
	"The \"(?:extended-)?remote\" target does not support \"run\"\.  Try \"help target\" or \"continue\"\." \
	"run for gt inferior is disabled"

    gdb_test "inferior 1" "Switching to inferior 1.*" "switch to host inferior"

    # Now try to "run".  We should restart and hit the breakpoint inserted
    # earlier again.
    gdb_test "run" "Starting program:.*$srcfile:$inside_kernel.*" \
	"restart host inferior and hit kernel bp" \
	{Start it from the beginning\? \(y or n\) } "y"

    set kfail ""
    # We should now be able to run to the end.
    if {[omp_is_level_zero_debug_api]} {
	set kfail "JIRA XDEPS/5062"
    }
    continue_openmp_program_to_termination "" "${kfail}"
}

foreach extension $openmp_languages_list {
    set device_list [omp_get_device_list $extension]
    if {[llength $device_list] == 0} {
	unsupported "target does not support OpenMP ${extension}"
	continue
    }

    standard_testfile "single-task.${extension}"
    set exe "${binfile}_${extension}"

    set option "additional_flags=-DOMIT_REPORT"
    if {[prepare_openmp_for_testing ${exe} ${srcfile} $extension $option]} {
	untested "OpenMP: Fail to prepare the test ${exe}"
	continue
    }

    foreach device_info "${device_list}" {
	with_test_prefix [init_openmp_device $device_info $extension] {

	    if {![require_openmp_device "GPU"]} {
		unsupported "test is aimed at Intel GPUs only"
		continue
	    }

	    if {![start_openmp_program $extension]} {
		untested "Fail to start the program"
		continue
	    }

	    # Re-run multiple times until termination, with and without
	    # inside/outside BPs.
	    foreach_with_prefix has_kernel_bp {0 1} {
		foreach_with_prefix has_outside_bp {0 1} {
		    clean_restart $exe
		    foreach_with_prefix iter {1 2 3} {
			run_end_to_end $has_kernel_bp $has_outside_bp $extension
		    }
		}
	    }

	    # Re-run multiple times, where either the host or the gt inferior
	    # is killed/detached.

	    foreach_with_prefix which_bp {inside outside} {
		foreach_with_prefix scenario {kill_host detach_host detach_gt} {
		    clean_restart $exe
		    foreach_with_prefix iter {1 2 3} {
			run_to_bp $which_bp $scenario $iter $extension
		    }
		}
	    }

	    # Run the restart scenario for non-stop mode enabled and disabled.

	    foreach_with_prefix non_stop_mode {"off" "on"} {
		clean_restart $exe
		run_restart_scenario $non_stop_mode $extension
	    }
	}
    }
}
