# Copyright 2020-2022 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Tests GDBs support for accessing variables in SYCL from different SIMD lanes.

load_lib sycl.exp

standard_testfile .cpp

proc test_bp_1 {} {
    global decimal

    gdb_test "print wi" " = .*"
    gdb_test "print lid" " = .*"

    # Call operator() explicitly to work around known limitations.
    set v1 [get_valueof "" "pgid.operator() (wi)" "NONE"]
    set v2 [get_valueof "" "gid" "NONE"]
    gdb_assert {{$v1 eq $v2}} "pgid.operator() (wi) == gid"

     gdb_test_expr_eq "ain\[gid\]" "in"
     gdb_test_expr_eq "acs\[lid\].c" "cs"

    # LCS may be implemented as reference.  Skip some output.
    if {[require_sycl_device "gpu" "Intel*"]} {
	setup_kfail "JIRA DOQG/2081" "*-*-*"
    }
    gdb_test "print lcs" " = .* 4"
}

proc test_bp_2 { {lane 0} } {
    global decimal

    gdb_test "print wi" " = .*"
    gdb_test "print lid" " = .*"

    # Call operator() explicitly to work around known limitations.
    set v1 [get_valueof "" "pgid.operator() (wi)" "NONE"]
    set v2 [get_valueof "" "gid" "NONE"]
    gdb_assert {{$v1 eq $v2}} "pgid.operator() (wi) == gid"

    # Flaky test on Gen12.
    if {[is_level_zero_debug_api] || [is_gen12]} {
	setup_kfail "JIRA DOQG/2081" "*-*-*"
    }
    set v1 [get_valueof "" "atmp\[gid\].a" "NONE"]
    set v2 [get_valueof "" "in" "NONE"]
    if {[require_sycl_device "gpu" "Intel*"]} {
	setup_kfail "JIRA DOQG/2081" "*-*-*"
    }
    gdb_assert {{$v1 eq $v2}} "atmp\[gid\].a == in"

    gdb_test_expr_eq "aout\[gid\]" "out"

    # LCS may be implemented as reference.  Skip some output.
    if {[require_sycl_device "gpu" "Intel*"]} {
	setup_kfail "JIRA DOQG/2081" "*-*-*"
    }
    gdb_test "print lcs" " = .* 4"
    gdb_test "print cs" " = 4"
}

# A generic function name is used to call it from the SYCL library.
proc "sycl_${gdb_test_file_name}_run_tests" {} {
    global srcfile

    if {[start_sycl_program] < 0} {
        return -1
    }

    set l1 [gdb_get_line_number "bp\.1"]
    set l2 [gdb_get_line_number "bp\.2"]

    gdb_breakpoint $l1
    gdb_continue_to_breakpoint "bp.1" ".*$srcfile:$l1.*"

    with_test_prefix "bp.1" {
	if { [current_thread_has_simd_lanes] } {
	    for {set i 0} {$i < 8} {set i [expr $i+4]} {
		with_test_prefix "lane $i" {
		    gdb_test "thread :$i" "Switching to thread .*:$i.*"

		    test_bp_1
		}
	    }
	} else {
	    test_bp_1
	}
    }

    # Make sure we're not stuck on bp.1.
    delete_breakpoints
    gdb_breakpoint $l2
    gdb_continue_to_breakpoint "bp.2" ".*$srcfile:$l2.*"

    with_test_prefix "bp.2" {
	if { [current_thread_has_simd_lanes] } {
	    for {set i 0} {$i < 8} {set i [expr $i+4]} {
		with_test_prefix "lane $i" {
		    gdb_test "thread :$i" "Switching to thread .*:$i.*"

		    test_bp_2 $i
		}
	    }
	} else {
	    test_bp_2
	}
    }
}

test_initialize
