# Copyright 2022 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Tests reading the work item index in a SYCL program.

load_lib sycl.exp

standard_testfile parallel-for-1D.cpp

if {[skip_sycl_tests]} {
    unsupported "target does not support SYCL"
    return 0
}

if {[prepare_sycl_for_testing $binfile $srcfile]} {
    return -1
}

if {[start_sycl_program] < 0} {
    return -1
}

set inside_callee [gdb_get_line_number "inside-kernel-callee"]
gdb_breakpoint $inside_callee

# Check that we read the work item index the same with and without the
# pretty printer.
gdb_continue_to_breakpoint "hit the callee bp" \
    ".*$srcfile:$inside_callee.*"

# If wi is '0', this is not a very interesting stop.  Resume, so that
# we switch to another thread.
set fill "\[^\r\n\]*"
if {[require_sycl_device "gpu" "Intel*"]} {
    setup_kfail "JIRA CMPLRLLVM/36590" "*-*-*"
}
gdb_test_multiple "print wi.common_array" "check for zero" {
    -re -wrap "\\{0\\}" {
	pass $gdb_test_name
	gdb_continue_to_breakpoint "hit the callee bp again" \
	    ".*$srcfile:$inside_callee.*"
    }
    -re -wrap "\\{$fill\\}" {
	pass $gdb_test_name
    }
}

set last_line [gdb_get_line_number "kernel-last-line"]
gdb_breakpoint $last_line

set wi_pretty "wi_pretty"
if {[require_sycl_device "gpu" "Intel*"]} {
    setup_kfail "JIRA CMPLRLLVM/36590" "*-*-*"
}
gdb_test_multiple "print wi" "print wi pretty" {
    -re -wrap " = cl::sycl::id<1> = \\{($decimal)\\}" {
	set wi_pretty $expect_out(1,string)
	pass $gdb_test_name
    }
}
verbose -log "wi_pretty: $wi_pretty"

set wi_raw "wi_raw"
if {[require_sycl_device "gpu" "Intel*"]} {
    setup_kfail "JIRA CMPLRLLVM/36590" "*-*-*"
}
gdb_test_multiple "print/r wi" "print wi raw" {
    -re -wrap "\\{common_array = \\{($decimal)\\}\\},$fill" {
	set wi_raw $expect_out(1,string)
	pass $gdb_test_name
    }
}
verbose -log "wi_raw: $wi_raw"

if {[require_sycl_device "gpu" "Intel*"]} {
    setup_kfail "JIRA CMPLRLLVM/36590" "*-*-*"
}
gdb_assert {{$wi_pretty == $wi_raw}} "pretty and raw wi are the same"
gdb_assert {{$wi_pretty != "0"}} "pretty wi is non-zero"

# Go up in the call stack and check again.  Because the work item
# index is passed as a parameter, it is valuable to do this check
# in the parallel-for lambda separately.
gdb_test "up"

set wiID_pretty "wiID_pretty"
gdb_test_multiple "print wiID" "print wiID pretty" {
    -re -wrap " = cl::sycl::id<1> = \\{($decimal)\\}" {
	set wiID_pretty $expect_out(1,string)
	pass $gdb_test_name
    }
}
verbose -log "wiID_pretty: $wiID_pretty"

set wiID_raw "wiID_raw"
gdb_test_multiple "print/r wiID" "print wiID raw" {
    -re -wrap "\\{common_array = \\{($decimal)\\}\\},$fill" {
	set wiID_raw $expect_out(1,string)
	pass $gdb_test_name
    }
}
verbose -log "wiID_raw: $wiID_raw"

gdb_assert {{$wiID_pretty == $wiID_raw}} "pretty and raw wiID are the same"
if {[require_sycl_device "gpu" "Intel*"]} {
    setup_kfail "JIRA CMPLRLLVM/36590" "*-*-*"
}
gdb_assert {{$wi_pretty == $wiID_pretty}} "pretty wi and wiID are the same"

# Use the local dim0 variable for a final validation.
gdb_test_no_output "set scheduler-locking on"
gdb_continue_to_breakpoint "hit the last line bp" \
    ".*$srcfile:$last_line.*"

set dim0_value [get_integer_valueof "dim0" "-1"]
gdb_assert {{$wiID_raw == $dim0_value}} "wiID raw and dim0 are the same"
