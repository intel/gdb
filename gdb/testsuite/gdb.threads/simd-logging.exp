# Copyright 2022 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Tests for the logging of the "thread" commands.

# This is a generic test, however, SIMD lanes are not supported by all
# targets.  For convenience, here the SYCL program with offload to the
# Intel GPU is used.

load_lib sycl.exp

standard_testfile simd.cpp

if { [skip_sycl_tests] } {
    unsupported "target does not support SYCL"
    return 0
}

if { ![require_sycl_device "gpu" "Intel*"] } {
    unsupported "test is aimed at Intel GPUs only"
    return 0
}

if { [prepare_sycl_for_testing $binfile $srcfile] } {
    return -1
}

proc thread_no_lane_re {thread} {
    global thread_id
    return [multi_line \
	"Thread $thread \\\(Thread ($thread_id)\\\):" \
	"\\\[Current thread is $thread \\\(Thread ($thread_id)\\\)\\\]" \
    ]
}

proc thread_with_lane_re {thread lane} {
    global thread_id
    return [multi_line \
	"Thread $thread:$lane \\\(Thread ($thread_id) lane $lane\\\):" \
	"\\\[Current thread is $thread:$lane \\\(Thread ($thread_id) lane $lane\\\)\\\]"
    ]
}

save_vars { GDBFLAGS } {
    append GDBFLAGS " -ex \"set non-stop on\""
    clean_restart ${binfile}
}

if { [start_sycl_program] < 0 } {
    return -1
}

set bp_odd_branch [gdb_get_line_number "kernel-odd-branch"]
gdb_breakpoint "$bp_odd_branch" {temporary}

set fill "\[^\r\n\]*"
set odd_branch_inf "invalid"
set odd_branch_thread "invalid"
gdb_test_multiple "continue -a" "continue to kernel-odd-branch" {
     -re "Thread ($decimal).($decimal)$fill hit Temporary breakpoint $decimal, with SIMD lanes \\\[1 3 5 7.*\\\],${fill}$srcfile:$bp_odd_branch\r\n" {
	set odd_branch_inf $expect_out(1,string)
	set odd_branch_thread $expect_out(2,string)
	exp_continue
    }
    -re "$gdb_prompt $" {
	gdb_assert { { $odd_branch_inf ne "invalid"} && {$odd_branch_thread ne "invalid"} } $gdb_test_name
    }
}

if {$odd_branch_inf eq "invalid" || $odd_branch_thread eq "invalid" } {
    return -1
}

# In non-stop mode we don't switch to the inferior which hit the breakpoint.
gdb_test "thread" "Current thread is 1.($decimal) \\\(Thread.*"\
    "currently running thread displays no lanes"

# Switch to thread which is executing at a breakpoint.
gdb_test "thread $odd_branch_inf.$odd_branch_thread" \
    "Switching to thread $odd_branch_inf.$odd_branch_thread:1 .*" \
    "switch to thread at default lane which is executing at the breakpoint"

set thread_id "($decimal\\.$decimal)|($hex)"
gdb_test "thread" \
    "\\\[Current thread is $odd_branch_inf.$odd_branch_thread:1 \\\(Thread ($thread_id) lane 1\\\)\\\]" \
    "print thread info for executing thread, lane information shall be printed"

gdb_test "thread apply :3 thread" \
    [thread_with_lane_re "$odd_branch_inf\.$odd_branch_thread" "3"] \
    "thread apply for specific lane of non executing thread"

gdb_test "thread :5" \
    "\\\[Switching to thread $odd_branch_inf.$odd_branch_thread:5 \\\(Thread ($thread_id) lane 5\\\)\\\].*" \
    "switch lane for a not executing thread"

gdb_test "print \$_simd_lane" \
    "= 5" \
    "print \$_simd_lane = 5"

# Extract thread which is running, but has inferior number $odd_branch_inf (thread on gpu).
set running_thread "invalid"
gdb_test_multiple "info threads" "extract running thread" {
    -re "$odd_branch_inf\.($decimal)${fill}Thread ($thread_id)${fill}\\\(running\\\)" {
	if {$running_thread eq "invalid"} {
	    set running_thread $expect_out(1,string)
	}
	exp_continue
    }
    -re "$gdb_prompt $" {
	gdb_assert { { $running_thread ne "invalid" } } $gdb_test_name
    }
}

verbose -log "running thread id: $running_thread"
verbose -log "odd branch thread id: $odd_branch_thread"

if {$running_thread eq "invalid"} {
  return -1
}

gdb_test "thread $odd_branch_inf.$running_thread" \
    "\\\[Switching to thread $odd_branch_inf.$running_thread \\\(Thread ($thread_id)\\\)\\\]\\\(running\\\)" \
    "switch to thread $odd_branch_inf.$running_thread which is executing"

gdb_test "thread" \
    "\\\[Current thread is $odd_branch_inf.$running_thread \\\(Thread ($thread_id)\\\)\\\]" \
    "print thread info for an executing thread, no error shall occur"

set first_thread_lane 1
gdb_test "thread :$first_thread_lane" \
    "Thread $odd_branch_inf.$running_thread is executing, cannot check SIMD lane status: Cannot specify SIMD lane" \
    "print error for switching lane on executing thread"

# Test that we print lane information for non executing threads but not for
# executing threads.
gdb_test "info threads 1.1" \
    "  1\.1 ${fill}Thread ($thread_id) \\\(LWP ($decimal)\\\) \"$testfile\" ${fill}\\\(running\\\)"

gdb_test "info threads $odd_branch_inf.$odd_branch_thread" \
    "  $odd_branch_inf\.$odd_branch_thread:\\\[1 3 5 7${fill}\\\] ${fill}Thread ($thread_id) ${fill}$srcfile:$bp_odd_branch" \
    "info threads for odd-branch-thread"

gdb_test "info threads $odd_branch_inf.$running_thread" \
    "\\* $odd_branch_inf\.$running_thread  ${fill}Thread ($thread_id) ${fill}\\\(running\\\)" \
    "info threads for running-thread"

# Test that we try to apply commands for executing and non executing threads.
# Make sure that we check the correct order by comparing the indices of
# $running_thread with $odd_branch_thread and using the flag "-ascending" if
# necessary.
if {$running_thread > $odd_branch_thread} {
    set command "thread apply all-lanes thread"
    set lane_1 7
    set lane_2 5
    set lane_3 3
    set lane_4 1
} else {
    set command "thread apply all-lanes -ascending thread"
    set lane_1 1
    set lane_2 3
    set lane_3 5
    set lane_4 7
}

gdb_test_sequence $command "thread apply all-lanes thread" [list \
    [thread_no_lane_re "$odd_branch_inf\.$running_thread"] \
    [thread_with_lane_re "$odd_branch_inf\.$odd_branch_thread" "$lane_1"] \
    [thread_with_lane_re "$odd_branch_inf\.$odd_branch_thread" "$lane_2"] \
    [thread_with_lane_re "$odd_branch_inf\.$odd_branch_thread" "$lane_3"] \
    [thread_with_lane_re "$odd_branch_inf\.$odd_branch_thread" "$lane_4"] \
]

# Test warning if we try to apply a command to a specific lane on an executing
# thread.
gdb_test "thread apply :3 thread" \
    "warning: Thread $odd_branch_inf\.$running_thread is executing, cannot check SIMD lane status: Cannot apply command on SIMD lane" \
    "thread apply warning for an executing thread if run for a specific lane."

# Test warning if we try to apply a command on lanes.
gdb_test "thread apply :* thread" \
     "warning: Thread $odd_branch_inf\.$running_thread is executing, cannot check SIMD lane status: Cannot apply command on SIMD lane" \
     "thread apply warning for an executing thread if run for lanes."
