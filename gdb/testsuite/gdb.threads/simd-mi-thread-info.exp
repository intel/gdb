# Copyright 2022 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Tests -thread-info and checks execution-mask and simd-width values.
#

load_lib sycl.exp

# Wait for breakpoint-hit event and return id of the stopped thread.
proc expect_breakpoint_hit {line test} {
    global mi_gdb_prompt

    gdb_expect {
	-re "\\*stopped,reason=\"breakpoint-hit\".*line=\"$line\".*thread-id=\"(\[0-9\]+)\".*\r\n$mi_gdb_prompt" {
	    pass "$test"
	    return $expect_out(1,string)
	}
	-re ".*$mi_gdb_prompt" {
	    fail "$test"
	}
	timeout {
	    fail "$test"
	}
    }
}

standard_testfile simd.cpp

# A generic function name is used to call it from the SYCL library.
proc "sycl_${gdb_test_file_name}_run_tests" {} {
    global binfile srcfile expect_out hex mi_gdb_prompt

    if {![require_sycl_device "gpu" "Intel*"]} {
	unsupported "test is aimed at Intel GPUs only"
	return 0
    }

    mi_clean_restart $binfile

    if {[mi_start_sycl_program] < 0} {
	return -1
    }

    set kernel_dim0_line [gdb_get_line_number "kernel-dim0-defined"]
    set odd_branch_line [gdb_get_line_number "kernel-odd-branch"]

    # Set temporary breakpoint to line $kernel_dim0_line and continue.
    mi_tbreak $kernel_dim0_line
    mi_send_resuming_command "exec-continue" "run to $kernel_dim0_line (exec-continue)"

    # Expect breakpoint-hit stop event and get the id of the stopped thread.
    set thread_id [expect_breakpoint_hit $kernel_dim0_line "expect breakpoint-hit event at line $kernel_dim0_line"]

    # First get _simd_width convenience variable value to compare correctness of
    # the MI command output.
    mi_gdb_test "-data-evaluate-expression \$_simd_width" \
	"\\^done,value=\".*\"" \
	"Get \$_simd_width value"

    set output $expect_out(buffer)
    regexp {value=\"(.*)\"} $output -> simd_width

    # Calculate the expected emask.
    set mask 0xffffffff
    set emask_int [expr $mask & int(pow(2, $simd_width) - 1)]
    set emask_hex [format 0x%x $emask_int]

    mi_gdb_test "-thread-info $thread_id" \
	"\\^done,threads=\\\[\{id=\".*\",target-id=.*,execution-mask=\"$emask_hex\",simd-width=\"$simd_width\",hit-lanes-mask=\"$hex\"\}\\\]" \
	"Check execution mask and simd width for thread $thread_id at line $kernel_dim0_line"

    # Set temporary breakpoint to line $odd_branch_line and continue.
    mi_tbreak $odd_branch_line
    mi_send_resuming_command "exec-continue" "run to $odd_branch_line (exec-continue)"

    # Expect breakpoint-hit stop event and get the id of the stopped thread.
    set thread_id [expect_breakpoint_hit $odd_branch_line "expect breakpoint-hit event at line $odd_branch_line"]

    # Calculate the expected emask.
    set mask 0xaaaaaaaa
    set emask_int [expr $mask & int(pow(2, $simd_width) - 1)]
    set emask_hex [format 0x%x $emask_int]

    mi_gdb_test "-thread-info $thread_id" \
	"\\^done,threads=\\\[\{id=\".*\",target-id=.*,execution-mask=\"$emask_hex\",simd-width=\"$simd_width\",hit-lanes-mask=\"$hex\"\}\\\]" \
	"Check execution mask and simd width for thread $thread_id at line $odd_branch_line"

    # Test a host thread that it does not contain emask or simd width fields.
    send_gdb "-thread-info 1\n"
    gdb_expect 10 {
	-re "execution-mask" { fail "host thread has no execution mask output"}
	-re "simd-width" { fail "host thread has no simd-width output"}
	-re "\\^done.*$mi_gdb_prompt$" { pass "no SIMD output" }
	timeout { fail "(timeout) -thread-info 1" }
    }

    # Continue to end.
    mi_send_resuming_command "exec-continue" "continuing to inferior exit"

    # Expect normal exit.
    mi_expect_stop "exited-normally" "" "" "" "" "" "exit normally"
}

test_initialize
