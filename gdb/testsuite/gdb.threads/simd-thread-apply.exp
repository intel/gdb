# Copyright 2020-2023 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Tests for SIMD support in ''thread apply' command.

# This is a generic test, however, SIMD lanes are not supported by all
# targets.  For convenience, to test this functionality, a SYCL
# program with the offload to Intel GPU is used here.

load_lib sycl.exp

standard_testfile simd-thread-apply.cpp

set sycl_device_list [init_sycl_devices_list]
if {[llength $sycl_device_list] == 0} {
    unsupported "target does not support SYCL"
    return 0
}

if {[build_executable "failed to compile $srcfile" \
    "${binfile}" $srcfile {sycl debug}]} {
    return -1
}

# Issue "thread apply TID_LIST p 1234" and expect EXP_TID_LIST (a list
# of thread ids) to be displayed.
proc thread_apply {tid_list exp_tid_list {message ""}} {
    global decimal
    set any "\[^\r\n\]*"
    set expected [string_to_regexp $exp_tid_list]

    # Set a tricky printed value.
    set printed_value "\"2-3:4-6\""
    set r ""
    foreach tid $expected {
	set match 0
	set inf_num 0
	regexp {(\d+)\.\*} $tid match inf_num
	if { $match eq $tid } {
	    # We got TID in the form INFERIOR.*, which means that
	    # the number of threads is arbitrary.
	    append r "\("
	    append r "\[\r\n\]+"
	    append r "Thread $inf_num\.$decimal$any:\r\n"
	    append r "\\$$decimal = $printed_value"
	    append r "\)*"
	} else {
	    append r "\[\r\n\]+"
	    append r "Thread $tid$any:\r\n"
	    append r "\\$$decimal = $printed_value"
	}
    }

    set message1 $message
    # Test standard thread apply command
    set cmd "thread apply $tid_list"
    append message $cmd
    gdb_test "$cmd p $printed_value" $r $message

    # Test thread apply command with a flag
    set cmd "thread apply $tid_list -c"
    append message1 $cmd
    gdb_test "$cmd p $printed_value" $r $message1
}

proc thread_apply_error {tid_list exp_error} {
   gdb_test "thread apply $tid_list p 1234" "$exp_error"
}

# Issue thread apply TID_LIST" and expect the command to error out
# with "Invalid thread ID: $EXPECTED". EXPECTED is a literal string,
# not a regexp.  If EXPECTED is omitted, TID_LIST is expected instead.
proc thread_apply_invalid {tid_list {expected ""}} {
    if {$expected eq ""} {
	set expected $tid_list
    }
    set expected [string_to_regexp $expected]

    gdb_test "thread apply $tid_list p 1234" \
	"Invalid thread ID: $expected p 1234" \
	"thread apply $tid_list"
}

# Convenience procedures to build a string of the form
# "thread:L1 thread:L2 ... thread:Ln".
proc lanes_of {thread lanes} {
    return [lmap x $lanes {string cat "$thread:" "$x"}]
}

proc all_lanes_of {num_lanes thread} {
    set lanes ""
    for {set i 0} {$i < $num_lanes} {incr i} {
	append lanes "$i "
    }
    return [lanes_of "$thread" "$lanes"]
}

proc all_even_lanes_of {num_lanes thread} {
    set lanes ""
    for {set i 0} {$i < $num_lanes} {incr i} {
	append lanes "$i "
	incr i
    }
    return [lanes_of "$thread" "$lanes"]
}

# Convenience procedure to build a regexp that matches numbers between
# FROM and TO, both exclusive.  Returns "none" if the range is empty.
proc range_re {from to} {
    set i [expr $from + 1]
    if {$i >= $to} {
	return "none"
    }

    set result "$i"
    incr i
    for {} {$i < $to} {incr i} {
	append result "|$i"
    }
    return $result
}

# Check that all lanes are preserved.
proc check_lanes {where inf t_1 t_2 t_3 t_4} {
    gdb_test "thread $inf.$t_2" "Switching to thread $inf.$t_2:3.*" \
	"thread $inf.$t_2 $where"
    gdb_test "thread $inf.$t_3" "Switching to thread $inf.$t_3:4.*" \
	"thread $inf.$t_3 $where"
    gdb_test "thread $inf.$t_4" "Switching to thread $inf.$t_4:5.*" \
	"thread $inf.$t_4 $where"
    gdb_test "thread $inf.$t_1" "Switching to thread $inf.$t_1:2.*" \
	"thread $inf.$t_1 $where"
}

foreach device $sycl_device_list {
    sycl_with_intelgt_lock $device {

	if {![require_sycl_device "$device" "gpu" "Intel*"]} {
	    unsupported "test is aimed at Intel GPUs only"
	    continue
	}

	clean_restart "${binfile}"

	if {![runto_main [sycl_get_device_args $device]]} {
	    continue
	}

	set first_line [gdb_get_line_number "kernel-first-line"]
	set even_branch [gdb_get_line_number "kernel-even-branch"]

	gdb_breakpoint "$first_line" {temporary}
	gdb_continue_to_breakpoint "hit the first BP" ".*$srcfile:$first_line.*"

	set first_thread [get_current_thread "after first BP hit"]

	# Switching to non-zero SIMD lane.
	gdb_test "thread :6" "Switching to thread $first_thread:6.*"

	# Check error handling
	gdb_test "p \$one = 1" " = 1"
	gdb_test "p \$minus_one = -1" " = -1"
	gdb_test "p \$two = 2" " = 2"
	gdb_test "p \$three = 3" " = 3"
	foreach prefix {"" "2" "\$one" "2-3" "2.2" "\$one.\$two-3"} {
	    thread_apply_invalid "$prefix:-"
	    thread_apply_error "$prefix:-1" "negative value"
	    thread_apply_error "$prefix:\$minus_one" "Incorrect SIMD lane number: -1."
	    thread_apply_invalid "$prefix:-*"
	    thread_apply_invalid "$prefix:*-"
	    thread_apply_invalid "$prefix:*-1"
	    thread_apply_invalid "$prefix:1*"
	    thread_apply_invalid "$prefix:1-"
	    thread_apply_invalid "$prefix:1-*"
	    thread_apply_invalid "$prefix:1-2-3"
	    thread_apply_invalid "$prefix:1-*-3"
	    thread_apply_invalid "$prefix:1-2-*"
	    thread_apply_invalid "$prefix:1:2"
	    thread_apply_invalid "$prefix:1:2-3"
	    thread_apply_invalid "$prefix:1-3:2"
	    thread_apply_error "$prefix:3-\$one" "inverted range"
	    thread_apply_error "$prefix:128" "Incorrect SIMD lane number: 128."
	}

	# Point goes after the colon.
	thread_apply_invalid "3:2.1"

	# Default thread
	thread_apply ":3" "$first_thread:3"
	thread_apply "$first_thread" "$first_thread:6"
	thread_apply ":3-5" "$first_thread:3 $first_thread:4 $first_thread:5"
	thread_apply ":*" \
	    "$first_thread:0 $first_thread:1 $first_thread:2 $first_thread:3 $first_thread:4 $first_thread:5 $first_thread:6 $first_thread:7 2.*"

	# Switch threads to non-zero SIMD lanes.
	gdb_test "thread 2.2:2" "Switching to thread 2.2:2.*"
	gdb_test "thread 2.3:3" "Switching to thread 2.3:3.*"
	gdb_test "thread 2.4:4" "Switching to thread 2.4:4.*"
	gdb_test "thread 2.5:5" "Switching to thread 2.5:5.*"

	foreach prefix {"" "2."} {
	    # Thread ID
	    thread_apply "${prefix}2" "2.2:2" " before branch "
	    thread_apply "${prefix}2:3" "2.2:3" " before branch "
	    thread_apply "${prefix}2:3-5" "2.2:3 2.2:4 2.2:5" " before branch "
	    thread_apply "${prefix}2:*" \
		"2.2:0 2.2:1 2.2:2 2.2:3 2.2:4 2.2:5 2.2:6 2.2:7 2.*" " before branch "

	    # Thread range
	    thread_apply "${prefix}2-3" "2.2:2 2.3:3" " before branch "
	    thread_apply "${prefix}2-3:4" "2.2:4 2.3:4" " before branch "
	    thread_apply "${prefix}2-\$three:3-4" "2.2:3 2.2:4 2.3:3 2.3:4" \
		" before branch "
	    thread_apply "${prefix}2-3:*" \
		"2.2:0 2.2:1 2.2:2 2.2:3 2.2:4 2.2:5 2.2:6 2.2:7 2.* 2.3:0 2.3:1 2.3:2 2.3:3 2.3:4 2.3:5 2.3:6 2.3:7 2.*" \
		" before branch "

	    # Wildcard thread range
	    thread_apply "${prefix}*" "2.2:2 2.3:3 2.4:4 2.5:5 2.*" " before branch "
	    thread_apply "${prefix}*:3" "2.2:3 2.3:3 2.4:3 2.5:3 2.*" " before branch "
	    thread_apply "${prefix}*:\$three-5" \
		"2.2:3 2.2:4 2.2:5 2.3:3 2.3:4 2.3:5 2.4:3 2.4:4 2.4:5 2.5:3 2.5:4 2.5:5 2.*" \
		" before branch "
	    thread_apply "${prefix}*:*" \
		"2.2:0 2.2:1 2.2:2 2.2:3 2.2:4 2.2:5 2.2:6 2.2:7 2.* 2.3:0 2.3:1 2.3:2 2.3:3 2.3:4 2.3:5 2.3:6 2.3:7 2.* 2.4:0 2.4:1 2.4:2 2.4:3 2.4:4 2.4:5 2.4:6 2.4:7 2.* 2.5:0 2.5:1 2.5:2 2.5:3 2.5:4 2.5:5 2.5:6 2.5:7 2.*" \
		" before branch "
	}

	check_lanes "after first apply group" $inf $t_1 $t_2 $t_3 $t_4

	# Check thread apply all
	thread_apply "all" "2.5.5 2.4:4 2.3:3 2.2:2 2.1 1.* 1.1"

	check_lanes "after apply all" $inf $t_1 $t_2 $t_3 $t_4

	thread_apply "all-lanes" \
	    "2.5:7 2.5:6 2.5:5 2.5:4 2.5:3 2.5:2 2.5:1 2.5:0 2.* 2.4:7 2.4:6 2.4:5 2.4:4 2.4:3 2.4:2 2.4:1 2.4:0 2.* 2.3:7 2.3:6 2.3:5 2.3:4 2.3:3 2.3:2 2.3:1 2.3:0 2.* 2.2:7 2.2:6 2.2:5 2.2:4 2.2:3 2.2:2 2.2:1 2.2:0 1.* 1.1"

	thread_apply "all-lanes -ascending" \
	    "1.1 1.* 2.2:0 2.2:1 2.2:2 2.2:3 2.2:4 2.2:5 2.2:6 2.2:7 2.* 2.3:0 2.3:1 2.3:2 2.3:3 2.3:4 2.3:5 2.3:6 2.3:7 2.* 2.4:0 2.4:1 2.4:2 2.4:3 2.4:4 2.4:5 2.4:6 2.4:7 2.* 2.5:0 2.5:1 2.5:2 2.5:3 2.5:4 2.5:5 2.5:6 2.5:7 2.*"

	check_lanes "after apply all-lanes" $inf $t_1 $t_2 $t_3 $t_4

	#  Check that several intervals are parsed correctly.
	#  The set of combinations is incomplete.
	foreach prefix {"" "2" "2.2"} {
	    set end "2.2:2"
	    if {$prefix eq ""} {
		set end ""
	    }
	    thread_apply "2:* ${prefix}" \
		"2.2:0 2.2:1 2.2:2 2.2:3 2.2:4 2.2:5 2.2:6 2.2:7 2.* $end" " combinations "
	    thread_apply "2 ${prefix}:3" "2.2.2 2.2:3" " combinations "
	    thread_apply "2-3:3-4 ${prefix}:3-5 2" \
		"2.2:3 2.2:4 2.3:3 2.3:4 2.2:3 2.2:4 2.2:5 2.2:2" " combinations "
	    thread_apply "*:3 ${prefix}:* :*" \
		"2.2:3 2.3:3 2.4:3 2.5:3 2.* 2.2:0 2.2:1 2.2:2 2.2:3 2.2:4 2.2:5 2.2:6 2.2:7 2.* 2.2:0 2.2:1 2.2:2 2.2:3 2.2:4 2.2:5 2.2:6 2.2:7 2.*" \
		" combinations "
	    thread_apply "*:3 ${prefix}:* :2-3" \
		"2.2:3 2.3:3 2.4:3 2.5:3 2.* 2.2:0 2.2:1 2.2:2 2.2:3 2.2:4 2.2:5 2.2:6 2.2:7 2.* 2.2:2 2.2:3" \
		" combinations "
	}

	# At even branch, lanes [0 2 4 6] are active
	gdb_breakpoint "$even_branch" {temporary}
	gdb_continue_to_breakpoint "hit the BP at even branch " \
	    ".*$srcfile:$even_branch.*"

	# Only even lanes are active.
	thread_apply_error ":1" \
	    "warning: SIMD lane 1 is inactive in thread $first_thread"

	# After BP hit, the thread 2.2 should be preserved
	thread_apply ":4" "2.2:4" " at even branch "
	thread_apply ":*" "2.2:0 2.2:2 2.2:4 2.2:6 2.*" " at even branch "
	thread_apply_error ":3" "warning: SIMD lane 3 is inactive in thread 2.2."

	# Set thread 2.3 to active lane.
	gdb_test "thread 2.3:2" "Switching to thread 2.3:2.*" \
	    "Switch to thread 2.3:2 at even branch"
	# Set current thread to 2.2
	gdb_test "thread 2.2:2" "Switching to thread 2.2:2.*" \
	    "Switch to thread 2.2:2 at even branch"

	foreach prefix {"" "2."} {
	    # Thread ID
	    thread_apply "${prefix}2" "2.2:2" " at even branch "
	    thread_apply "${prefix}2:4" "2.2:4" " at even branch "
	    thread_apply "${prefix}2:*" "2.2:0 2.2:2 2.2:4 2.2:6 2.*" " at even branch "

	    # Thread range
	    thread_apply "${prefix}2-3" "2.2:2 2.3:2" " at even branch "
	    thread_apply "${prefix}2-3:4" "2.2:4 2.3:4" " at even branch "
	    thread_apply "${prefix}2-3:*" \
		"2.2:0 2.2:2 2.2:4 2.2:6 2.* 2.3:0 2.3:2 2.3:4 2.3:6 2.*" " at even branch "

	    # Wildcard thread range
	    thread_apply "${prefix}*" "2.2:2 2.3:2 2.4:4 2.5:0 2.*" " at even branch "
	    thread_apply "${prefix}*:4" "2.2:4 2.3:4 2.4:4 2.5:4 2.*" " at even branch "
	    thread_apply "${prefix}*:*" \
		[string cat \
		    [all_even_lanes_of $num_lanes "$inf.$t_1"] " " \
		    [all_even_lanes_of $num_lanes "$inf.$t_2"] " " \
		    [all_even_lanes_of $num_lanes "$inf.$t_3"] " " \
		    [all_even_lanes_of $num_lanes "$inf.$t_4"]] \
	    $msg "$inf\.$decimal:$decimal" "none"
	}
    }
}
