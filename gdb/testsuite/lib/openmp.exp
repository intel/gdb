# Copyright 2020-2023 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Support library for testing OpenMP debugging in GDB.

# Return compiler flags for OpenMP.
load_lib fortran.exp

if {![info exists openmp_device_generation]} {
    set openmp_device_generation ""
}
if {![info exists openmp_device_id]} {
    set openmp_device_id ""
}

if {![info exists OFFLOAD_DEVICE_GROUP]} {
    set OFFLOAD_DEVICE_GROUP "cpu,host,gpu"
}

if {![info exists OFFLOAD_BACKEND_GROUP]} {
    set OFFLOAD_BACKEND_GROUP "level0,opencl"
}

if {[info exists OPENMP_LANG_GROUP]} {
    set openmp_languages_list {}
    set openmp_languages [split "$OPENMP_LANG_GROUP" ","]
    foreach lang $openmp_languages {
	if {$lang eq "cpp"} {
	    lappend openmp_languages_list "cpp"
	} elseif {$lang eq "fortran"} {
	    lappend openmp_languages_list "f90"
	}
    }
} else {
    set openmp_languages_list {"cpp" "f90"}
}

# Run a test on the target for checking if it supports OpenMP.  Return 0 if
# OpenMP is supported, 1 otherwise.

proc skip_openmp_tests {device} {
    global srcdir subdir objdir inferior_exited_re env decimal hex
    global openmp_device_generation openmp_device_id

    set result 1
    with_test_prefix [init_openmp_device "$device"] {
	set exe "$objdir/openmp-devices"
	set src "$srcdir/lib/openmp-devices.cpp"

	if {[build_executable "failed to compile $src" \
	    "${exe}" $src {openmp c++ debug}]} {
	    verbose "OpenMP: Compilation failed." 0
	    return 1
	}

	# Number of devices is always returned 0 in case of OpenMP Host offload so
	# in this case testing is not skipped due to this.
	if {[info exists env(OMP_TARGET_OFFLOAD)]} {
	    if {"$env(OMP_TARGET_OFFLOAD)" eq "DISABLED"} {
		return 0
	    }
	}

	clean_restart $exe

	set gdbserver_started 0
	set test "Test OpenMP support"
	gdb_test_multiple "run" $test {
	    -re "id ($hex) \\\((Gen$decimal)\\\).*\r\n" {
		set openmp_device_id $expect_out(1,string)
		set openmp_device_generation $expect_out(2,string)
		exp_continue
	    }
	    -re "intelgt: attached to device.*(Intel.*).*\r\n" {
		set openmp_device_generation $expect_out(1,string)
		exp_continue
	    }
	    -re "intelgt: gdbserver-ze started for process.*\r\n" {
		set gdbserver_started 1
		exp_continue
	    }
	    -re -wrap "$inferior_exited_re normally].*" {
		if {!$gdbserver_started
		    && [require_openmp_device "GPU"]} {
		    set result 1
		} else {
		    set result 0
		}
	    }
	    -re -wrap "$inferior_exited_re with code.*" {
		set result 1
	    }
	    -re -wrap "received signal SIGABRT, Aborted.*" {
		set result 1
	    }
	    -re "Quit anyway\\? \\(y or n\\) $" {
		send_gdb "y\n"
		set result 1
	    }
	}
    }

    gdb_exit

    return $result
}

# Call cpp or fortran main function according to extension value.

proc openmp_run_to_main {extension} {
    set result 1
    if {$extension eq "f90"} {
	if {![fortran_runto_main]} {
	    set result 0
	}
    } else {
	if {![runto_main]} {
	    set result 0
	}
    }

    return $result
}

# Return true if the OpenMP device selected via the env
# matches the arguments.  Otherwise return false.
# Exact match is used for LIBOMPTARGET_DEVICETYPE env.
# As the LIBOMPTARGET_DEVICETYPE can only meaningfully be set to CPU and GPU
# it is set to "" in case we are doing host offload.  Thus, host offload can
# be queried via `require_openmp_device ""`.

proc require_openmp_device {type} {
    global env

	if {![info exists env(OMP_TARGET_OFFLOAD)]
	|| ("$env(OMP_TARGET_OFFLOAD)" ne "DISABLED"
	    && ![info exists env(LIBOMPTARGET_DEVICETYPE)])} {
	verbose "OpenMP: test parameters not set; use LIBOMPTARGET_DEVICETYPE env" 0
	return 0
    }

    return [expr { $env(LIBOMPTARGET_DEVICETYPE) eq $type }]
}

# Initialize the environment for OpenMP offload according to input
# device value.

proc init_openmp_device {device_info} {
    global env openmp_device_generation openmp_device_id

    set device_list [split "$device_info" ";"]
    set device [lindex $device_list 0]
    set backend [lindex $device_list 1]

    if {[llength $device_list] > 2} {
	set openmp_device_generation [lindex $device_list 2]
	set openmp_device_id [lindex $device_list 3]
    }

    if {[string match "host" $device]} {
	set env(OMP_TARGET_OFFLOAD) "DISABLED"
	set env(LIBOMPTARGET_DEVICETYPE) "host"
    } else {
	set env(LIBOMPTARGET_DEVICETYPE) [string toupper $device]
	set env(LIBOMPTARGET_PLUGIN) $backend
	set env(OMP_TARGET_OFFLOAD) "MANDATORY"
    }

    return "$device:$backend"
}

# Returns 0 is device name is unexpected, otherwise returns 1.

proc is_omp_supported_device {device} {
    if {[string match -nocase "host" $device]
	|| [string match -nocase "cpu" $device]
	|| [string match -nocase "gpu" $device]} {
	return 1
    }

    return 0
}

# Returns list of supported OpenMP devices list.

gdb_caching_proc omp_get_device_list {} {
    global OFFLOAD_DEVICE_GROUP OFFLOAD_BACKEND_GROUP
    global openmp_device_generation openmp_device_id

    set device_list {}

    if {![is_omp_offload_supported_compiler]} {
	unsupported "OpenMP tests supported only for dpcpp and icpx compilers."
	return $device_list
    }

    set defined_device_list [split "$OFFLOAD_DEVICE_GROUP" ","]
    foreach device $defined_device_list {
	if {![is_omp_supported_device $device]} {
	    verbose "OpenMP device name $device is unknown." 0
	    continue
	}

	if {[string match "gpu" $device]
	    && [string match "*level*" $OFFLOAD_BACKEND_GROUP]} {
	    if {![skip_openmp_tests "$device;level0"]} {
		lappend device_list "${device};level_zero;$openmp_device_generation;$openmp_device_id"
	    }
	}

	if {[string match "*opencl*" $OFFLOAD_BACKEND_GROUP]} {
	    if {![skip_openmp_tests "$device;opencl"]} {
		lappend device_list "${device};opencl;$openmp_device_generation;$openmp_device_id"
	    }
	}
    }

    if {[llength $device_list] == 0} {
	verbose "OpenMP: Target does not support OpenMP." 0
    } else {
	verbose "OpenMP: List of supported devices ${device_list}." 0
    }
    return $device_list
}

# Get compiler info and return 1 if the compiler is icpx or ifx,
# otherwise return 0.

gdb_caching_proc is_omp_offload_supported_compiler {} {

    if {($extension eq "f90" && [test_compiler_info {ifx-*} f90])
	 || ($extension eq "c++" && [test_compiler_info {icx-*} c++])} {
	return 1
    }
    return 0
}
