# Copyright 2019-2022 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Support library for testing SYCL GDB features
#
# A particular SYCL device can be selected by passing the SYCL program
# two command-line arguments:
#   1. the device type, whose value is in {host, cpu, gpu, accelerator}.
#   2. a substring of the device name.
#
# To set these arguments properly, use a SYCL board file, and
# make your test program select a queue via the get_sycl_queue
# function in gdb.sycl/sycl-util.cpp.  See gdb.sycl/sycl-hello.cpp
# for a sample SYCL program setup.

# Define global variables for the driver version and platform.

load_lib mi-support.exp

if {![info exists sycl_driver_version]} {
    set sycl_driver_version ""
}
if {![info exists sycl_driver_platform]} {
    set sycl_driver_platform ""
}
if {![info exists sycl_selected_device]} {
    set sycl_selected_device ""
}
if {![info exists OFFLOAD_GPU_ID]} {
    set OFFLOAD_GPU_ID ""
}
if {![info exists OFFLOAD_DEVICE_GROUP]} {
    set OFFLOAD_DEVICE_GROUP ""
}
if {![info exists OFFLOAD_IGNORE_PREPARE_FOR_TESTING]} {
    set OFFLOAD_IGNORE_PREPARE_FOR_TESTING "0"
}
if {![info exists OFFLOAD_PERF_AOT_TESTING]} {
    set OFFLOAD_PERF_AOT_TESTING "0"
}

# Start the process by passing the SYCL device type and a
# substring of the device name as the command line arguments.

proc start_sycl_program {} {
    global device_type device_name sycl_driver_platform
    global gdb_prompt

    if {![info exists device_type] || ![info exists device_name]
	|| ![info exists sycl_driver_platform]} {
	verbose "SYCL: test parameters not set" 0
	return -1
    }

    # Because we're doing an internal setup, use gdb_test_multiple
    # instead of gdb_test to not include this as a pass.
    set set_args_cmd "set args '$device_type' '$device_name' '$sycl_driver_platform'"
    gdb_test_multiple $set_args_cmd $set_args_cmd {
	-re "$gdb_prompt $" { }
    }

    if {![runto_main]} {
	untested "failed to run to main"
	return -1
    }

    return 0
}

# Start SYCL program using MI commands.

proc mi_start_sycl_program {} {
    global device_type device_name sycl_driver_platform
    global mi_gdb_prompt

    if {![info exists device_type] || ![info exists device_name]
	|| ![info exists sycl_driver_platform]} {
	verbose "SYCL: test parameters not set" 0
	return -1
    }

    # Because we're doing an internal setup, use send_gdb and gdb_expect
    # instead of mi_gdb_test to not include this as a pass.
    send_gdb "-gdb-set args '$device_type' '$device_name' '$sycl_driver_platform'\n"
    gdb_expect 10 {
	-re "\\^done.*$mi_gdb_prompt$" { }
    }

    if {[mi_runto_main] == -1} {
	untested "failed to run to main"
	return -1
    }

    return 0
}

# Return true if the SYCL device selected via the board file
# matches the arguments.  Otherwise return false.
# For the device type, exact match is used.  For the device name,
# pattern-matching is used.

proc require_sycl_device {type name} {
    global device_type sycl_driver_platform
    global device_name

    if {![info exists device_type] || ![info exists device_name]
	|| ![info exists sycl_driver_platform]} {
	verbose "SYCL: test parameters not set" 0
	return 0
    }

    set type_match [expr {$device_type eq $type}]
    set name_match [string match $name $device_name]

    return [expr $type_match && $name_match]
}

# Run a test on the target to check if it recognizes SYCL.
# Remove device from the available devices list if SYCL is not supported
# and return the updated list.

proc get_sycl_supported_devices {sycl_device_list} {
    global srcdir objdir subdir gdb_prompt inferior_exited_re
    global OFFLOAD_IGNORE_PREPARE_FOR_TESTING

    set supported_sycl_device_list {}

    # Set up, compile, and execute a simple SYCL program.
    set exe "$objdir/sycl-hello"
    set src "$srcdir/lib/sycl-hello.cpp"

    # Don't re-compile in case OFFLOAD_IGNORE_PREPARE_FOR_TESTING option
    # is set.
    if {$OFFLOAD_IGNORE_PREPARE_FOR_TESTING != "1"} {
	if {[build_executable "failed to compile $src" \
			    $exe $src {sycl debug}]} {
	    verbose "SYCL: Compilation failed" 0
	    return 1
	}
	verbose -log "\nSYCL: Compilation succeeded"
    }

    foreach device $sycl_device_list {
	if ![is_sycl_device_filtered $device] {
	    continue
	}

	set test_prefix [sycl_init_device "$device"]
	if {[string match "" $test_prefix]} {
	    continue
	}

	clean_restart "${exe}"

	if {[start_sycl_program] < 0} {
	    continue
	}

	set result 1
	set gdbserver_started 0
	gdb_test_multiple "continue" "continue" {
	    -re -wrap "$inferior_exited_re normally].*" {
		if {!$gdbserver_started
		    && [require_sycl_device $device "gpu" "Intel*"]} {
		    set result 1
		} else {
		    set result 0
		}
	    }
	    -re -wrap "$inferior_exited_re with code.*" {
		set result 1
	    }
	    -re "intelgt: gdbserver-ze started for process.*\r\n" {
		set gdbserver_started 1
		exp_continue
	    }
	    -re -wrap "received signal SIGABRT, Aborted.*" {
		set result 1
	    }
	}

	if {$result == 0} {
	    verbose "SYCL: Support detected for ${device}" 0
	    lappend supported_sycl_device_list "${device}"
	} else {
	    verbose "SYCL: Support not detected for ${device}" 0
	}

	gdb_exit
    }

    return $supported_sycl_device_list
}

# Get list of devices and return 0 if device list is non-empty else
# return 1.

gdb_caching_proc init_sycl_devices_list {
    global srcdir objdir subdir gdb_prompt
    global inferior_exited_re
    global sycl_device_list
    global env OFFLOAD_IGNORE_PREPARE_FOR_TESTING

    set sycl_device_list {}
    set supported_sycl_device_list {}

    if {![is_sycl_offload_supported_compiler]} {
	unsupported "SYCL tests supported only for dpcpp and icpx compilers"
	return $sycl_device_list
    }

    # Set up, compile, and execute a simple SYCL program.
    set exe "$objdir/sycl-devices"
    set src "$srcdir/lib/sycl-devices.cpp"

    # Don't re-compile in case OFFLOAD_IGNORE_PREPARE_FOR_TESTING option
    # is set.
    if {$OFFLOAD_IGNORE_PREPARE_FOR_TESTING == "1"} {
	clean_restart $exe
    } else {
	if {[prepare_for_testing "failed to compile $src" \
		$exe $src {sycl debug}]} {
	    verbose "SYCL: Compilation failed" 0
	    return $sycl_device_list
	}
	verbose -log "\nSYCL: Compilation succeeded"
    }

    if {![runto_main]} {
	untested "failed to run sycl-devices to main"
	return $sycl_device_list
    }

    set result 1
    gdb_test_multiple "continue" "continue" {
	-re "SYCL: List of Target devices: \\\[(.*)\\\]" {
	    set sycl_device_list [split $expect_out(1,string) ","]
	    exp_continue
	}
	-re -wrap "$inferior_exited_re normally].*" {
	    set result 0
	}
	-re -wrap "$inferior_exited_re with code.*" {
	    set result 1
	}
    }

    set supported_sycl_device_list [get_sycl_supported_devices $sycl_device_list]
    if {($result == 0) && ([llength $supported_sycl_device_list])} {
	verbose "SYCL: Devices found: $supported_sycl_device_list" 0
    } else {
	set result 1
	verbose "SYCL: No device found" 0
    }

    gdb_exit

    return $supported_sycl_device_list
}

# Return non-zero, if we are runing at Level-Zero.

proc is_level_zero {} {
    global sycl_driver_platform
    return [regexp {.*(Level-Zero)} $sycl_driver_platform]
}

# Return non-zero, if we are runing on OpenCL.

proc is_opencl {} {
    global sycl_driver_platform
    return [regexp {.*(OpenCL)} $sycl_driver_platform]
}

# Return non-zero, if the Level-Zero Debug API is being used.

proc is_level_zero_debug_api {} {
    global env

    if {![info exists env(ZET_ENABLE_PROGRAM_DEBUGGING)]} {
	return 0
    }

    set env_var $env(ZET_ENABLE_PROGRAM_DEBUGGING)
    if {[string is integer $env_var]} {
	return [expr $env_var ne "0"]
    } else {
	return 0
    }
}

# Issue a 'continue' command and expect to see program termination.

proc continue_sycl_program_to_termination {{msg_suffix ""} {known_fail ""}} {
    global gdb_prompt inferior_exited_re

    if { $known_fail ne "" } { setup_kfail $known_fail "*-*-*" }

    gdb_test "continue" "$inferior_exited_re normally].*" \
	"continue to end $msg_suffix"
}

# Return the ID of a current thread (<inferior number>.<thread number>).
# SIMD lane information is omitted.
# For thread 2.3:0 returns "2.3".
# For thread 3:5 returns "3".
proc get_current_thread {location} {
    global gdb_prompt decimal

    gdb_test_multiple "thread" "get current thread at $location" {
	-re "Current thread is ($decimal|$decimal\.$decimal).*$gdb_prompt $" {
	    pass $gdb_test_name
	    return $expect_out(1,string)
	}
	-re "$gdb_prompt $" {
	    fail $gdb_test_name
	}
    }
    return 0
}

# Returns a non-negative integer value of variable VAR for SIMD lane
# LANE_NUM in the current thread.
# Returns -1 on error.
proc get_var_for_lane {var {lane_num 0}} {
    global decimal
    global gdb_prompt

    gdb_test "thread :$lane_num" ":$lane_num.*" \
	"switch the current thread to lane $lane_num"

    set msg "get $var value for the current thread, lane $lane_num"
    gdb_test_multiple "print $var" $msg {
	-re "= ($decimal).*$gdb_prompt" {
	    pass $gdb_test_name
	    return $expect_out(1,string)
	}
	-re "$gdb_prompt" {
	    fail $gdb_test_name
	    return -1
	}
    }
}

# Returns 1 if the current thread has SIMD lanes, 0 if it doesn't.
# Returns -1 on error.

proc current_thread_has_simd_lanes {} {
    global gdb_prompt decimal

    gdb_test_multiple "thread" "current_thread_has_simd_lanes" {
	-re "Current thread is $decimal.$decimal:$decimal .*$gdb_prompt $" {
	    return 1
	}
	-re "Current thread is $decimal:$decimal .*$gdb_prompt $" {
	    return 1
	}
	-re "Current thread is .*$gdb_prompt $" {
	    return 0
	}
	-re "$gdb_prompt $" {
	    fail $gdb_test_name
	    return 0
	}
    }

    fail $gdb_test_name
    return 0
}

# Returns the ID of the first stopped thread at $srcfile:$line that is not
# among ids_to_ignore. The returned thread ID is in the format of
# (<inferior number>.<thread number>) and SIMD lane information is omitted.
# For thread 2.3:0 returns "2.3".
# Returns "invalid" if no thread ID is found with given parameters.
proc get_another_stopped_thread {srcfile line ids_to_ignore {msg ""}} {
    global gdb_prompt decimal

    if [string match "" $msg] {
	set msg "get another stopped thread"
    }

    # Frame arguments are irrelevant.  Ignore them for faster results.
    set wpfa "with print frame-arguments none -- "

    set another_stopped_thread "invalid"
    gdb_test_multiple "${wpfa}info threads -stopped" $msg -lbl {
	-re "\r\n. ($decimal\(\.$decimal\)?)\[^\r\n\]* at $srcfile:$line" {
	    if {$another_stopped_thread eq "invalid"} {
		set next_thread $expect_out(1,string)
		if {[lsearch $ids_to_ignore $next_thread] == -1} {
		    set another_stopped_thread $next_thread
		}
	    }
	    exp_continue
	}
	-re "$gdb_prompt $" {
	    gdb_assert { { $another_stopped_thread ne "invalid" } } $gdb_test_name
	}
    }

    return $another_stopped_thread
}

# Returns 1 if the target device is selected via OFFLOAD_DEVICE_GROUP
# and OFFLOAD_GPU_ID, 0 otherwise.

proc is_sycl_device_filtered {device} {
    global OFFLOAD_DEVICE_GROUP OFFLOAD_GPU_ID

    # Filter according to OFFLOAD_DEVICE_GROUP.
    set device_info [split "$device" ";"]
    set device_type [lindex $device_info 3]
    set checking_gpu_device [string equal $device_type "gpu"]
    set checking_cpu_device [string equal $device_type "cpu"]
    set checking_fpga_device [string equal $device_type "accelerator"]
    set checking_host_device [string match -nocase "*Host*" $device]

    if {![string match "" $OFFLOAD_DEVICE_GROUP]} {
	if {($checking_cpu_device
	     && ![string match -nocase "*cpu*" $OFFLOAD_DEVICE_GROUP)])
	    || ($checking_host_device
		&& ![string match -nocase "*host*" $OFFLOAD_DEVICE_GROUP])
	    || ($checking_fpga_device
		&& ![string match -nocase "*accelerator*" $OFFLOAD_DEVICE_GROUP])
	    || ($checking_gpu_device
		&& ![string match -nocase "*gpu*" $OFFLOAD_DEVICE_GROUP])} {
	    return 0
	}
    }

    # Filter according to OFFLOAD_GPU_ID.
    if {![string match "" $OFFLOAD_GPU_ID]} {
	if {$checking_gpu_device
	    && ![string match -nocase "*${OFFLOAD_GPU_ID}*" $device]} {
	    return 0
	}
    }

    return 1
}

# Sets the global variables required for the arguments of SYCL tests and
# returns the test prefix which is used to identify the test for each device.

proc sycl_init_device {device} {
    global device_type device_name hex sycl_selected_device
    global sycl_driver_platform sycl_driver_version

    set device_info [split "$device" ";"]
    set sycl_driver_platform [lindex $device_info 1]
    set sycl_driver_version [lindex $device_info 2]
    set device_name ""

    if {[string match -nocase "*Graphics*" $device]
	|| [string match -nocase "*GPU*" $device]} {
	set device_type "gpu"
	set device_name [lindex $device_info 0]
	set sycl_selected_device [lindex $device_info 0]
	return "$device_type:$sycl_driver_platform:{[regexp -all -inline $hex $device_name]}"
    } elseif {[string match -nocase "*CPU*" $device]
	      || [string match -nocase "*CORE*" $device]} {
	set device_type "cpu"
	if {[string match "*Intel*" $device]} {
	    set device_name "Intel"
	}
	return "$device_type:$sycl_driver_platform:cpp"
    } elseif {[string match -nocase "*FPGA*" $device]} {
	set device_type "accelerator"
	if {[string match "*Intel*" $device]} {
	    set device_name "Intel"
	}
	return "$device_type:$sycl_driver_platform:cpp"
    } elseif {[string match -nocase "*Host*" $device]} {
	set device_type "host"
	return "$device_type:$sycl_driver_platform:cpp"
    }

    verbose "SYCL: Couldn't initialize device $device" 0
    return ""
}

# Iterate through available SYCL devices and call the run_tests
# function for each device.

proc test_initialize {{option ""}} {
    global binfile srcfile testfile OFFLOAD_IGNORE_PREPARE_FOR_TESTING

    set sycl_device_list [init_sycl_devices_list]
    if {[llength $sycl_device_list] == 0} {
	unsupported "target does not support SYCL"
	return 0
    }

    if {$OFFLOAD_IGNORE_PREPARE_FOR_TESTING != "1"} {
	if {[build_executable "failed to compile $srcfile" \
			    "${binfile}" $srcfile [concat sycl debug $option]]} {
	    return -1
	}
    }

    foreach device $sycl_device_list {
	set test_prefix [sycl_init_device "$device"]
	if {[string match "" $test_prefix]} {
	    verbose "SYCL: Ignoring unknown device name $device" 0
	    continue
	}

	clean_restart "${binfile}"
	with_test_prefix "$test_prefix" {
	    sycl_${testfile}_run_tests
	}
    }
}

# Get compiler info and return 1 if the compiler is icpx, otherwise
# return 0.

proc is_sycl_offload_supported_compiler {} {
    global OFFLOAD_IGNORE_PREPARE_FOR_TESTING

    if {$OFFLOAD_IGNORE_PREPARE_FOR_TESTING == "1"} {
	return 1
    }

    if {[test_compiler_info {icx-*} c++]} {
	return 1
    }

    return 0
}

# Get the namespace version for the SYCL header corresponding to the compiler
# used.  Return 0 for older compilers using SYCL without namespace versioning.

proc get_sycl_header_version {} {
    if {[test_compiler_info {icx-2023-*} c++]} {
	return 1
    }

    return 0
}

# Function is for the performance tests common "assemble section"
# of the tests.

proc sycl_perftest_initialize {} {
    global binfile srcfile OFFLOAD_PERF_AOT_TESTING

    set sycl_device_list [init_sycl_devices_list]
    if {[llength $sycl_device_list] == 0} {
	unsupported "target does not support SYCL"
	return 0
    }

    set option ""
    if {$OFFLOAD_PERF_AOT_TESTING == "1"} {
	# LD and compile flags setting is needed for AOT testing.
	# gen9: option creates AOT binary for gen9 and newer targets.
	set option [list "additional_flags=-fsycl-targets=spir64_x86_64,spir64_fpga,spir64_gen" "ldflags=-Xsycl-target-backend=spir64_gen \"-q -device gen9:\""]
    }

    if {[build_executable "failed to compile $srcfile" \
	    "${binfile}" $srcfile [concat sycl debug $option]]} {
	return 0
    }

    foreach device $sycl_device_list {
	set test_prefix [sycl_init_device "$device"]
	if {![string match "" $test_prefix]} {
	    verbose "SYCL: Initalized the device $device" 0
	    clean_restart "${binfile}"
	    return 1
	}
    }

    return 0
}
